{"ast":null,"code":"// constants\nimport { CACHE, DOTTY_WITH_BRACKETS_SYNTAX, MAX_CACHE_SIZE, NUMBER, QUOTED_KEY, VALID_KEY, WHITE_SPACE } from './constants';\n/**\n * @function isNumericKey\n *\n * @description\n * is the key passed a numeric string\n *\n * @param {string} key the key to test\n * @returns {boolean} is the key passed a numeric string\n */\n\nexport var isNumericKey = function isNumericKey(key) {\n  return !!(key && key.length) && NUMBER.test(key);\n};\n/**\n * @function isQuotedKey\n *\n * @description\n * is the key passed a quoted key\n *\n * @param {string} key the key to test\n * @returns {boolean} is the key a quoted key\n */\n\nexport var isQuotedKey = function isQuotedKey(key) {\n  return QUOTED_KEY.test(key);\n};\n/**\n * @function map\n *\n * @description\n * map the array to a new array based on fn\n *\n * @param {Array<*>} array the array to map\n * @param {function} fn the function to call with each iteration value\n * @returns {Array<*>} the mapped array\n */\n\nexport var map = function map(array, fn) {\n  var length = array.length;\n  var mapped = [];\n\n  for (var index = 0; index < length; index++) {\n    mapped[index] = fn(array[index]);\n  }\n\n  return mapped;\n};\n/**\n * @function shouldBeInBrackets\n *\n * @description\n * should the key passed be encased in brackets when in the path string\n *\n * @param {*} key the key that is being added to the path string\n * @returns {boolean} should the key be in brackets\n */\n\nexport var shouldBeInBrackets = function shouldBeInBrackets(key) {\n  return typeof key === 'number' || isNumericKey(key) || isQuotedKey(key);\n};\n/**\n * @function shouldBeInQuotes\n *\n * @description\n * should the key passed be encased in quotes when in the path string\n *\n * @param {*} key the key that is being added to the path string\n * @returns {boolean} should the key be in quotes\n */\n\nexport var shouldBeInQuotes = function shouldBeInQuotes(key) {\n  return WHITE_SPACE.test(key) || !VALID_KEY.test(key);\n};\n/**\n * @function createGetNormalizedCreateKey\n *\n * @description\n * get the normalized path string based on the quote and key passed\n *\n * @param {string} [quote=\"] the quote string to use\n * @returns {function(string, *): string}\n */\n\nexport var createGetNormalizedCreateKey = function createGetNormalizedCreateKey(quote) {\n  return function (existingString, key) {\n    var normalizedKey = shouldBeInQuotes(key) ? \"\" + quote + key + quote : key;\n    return existingString + (shouldBeInBrackets(normalizedKey) ? \"[\" + normalizedKey + \"]\" : \".\" + normalizedKey);\n  };\n};\n/**\n * @function getNormalizedParseKey\n *\n * @description\n * get the key as a number if parseable, or as a quoted string if applicable\n *\n * @param {string} key the key to try to parse\n * @returns {number|string} the parsed key\n */\n\nexport var getNormalizedParseKey = function getNormalizedParseKey(key) {\n  var cleanKey = isQuotedKey(key) ? key.slice(1, key.length - 1) : key;\n  return isNumericKey(cleanKey) ? +cleanKey : cleanKey;\n};\n/**\n * @function parsePath\n *\n * @description\n * parse the path, memoizing the results\n *\n * @param {string} path the path to parse\n * @returns {Array<number|string>} the parsed path\n */\n\nexport var parseStringPath = function parseStringPath(path) {\n  if (CACHE.results[path]) {\n    return CACHE.results[path];\n  }\n\n  if (CACHE.size > MAX_CACHE_SIZE) {\n    CACHE.clear();\n  }\n\n  CACHE.results[path] = path ? map(path.match(DOTTY_WITH_BRACKETS_SYNTAX), getNormalizedParseKey) : [path];\n  CACHE.size++;\n  return CACHE.results[path];\n};","map":{"version":3,"sources":["/home/ilkka/okta-redux-leash/node_modules/pathington/es/utils.js"],"names":["CACHE","DOTTY_WITH_BRACKETS_SYNTAX","MAX_CACHE_SIZE","NUMBER","QUOTED_KEY","VALID_KEY","WHITE_SPACE","isNumericKey","key","length","test","isQuotedKey","map","array","fn","mapped","index","shouldBeInBrackets","shouldBeInQuotes","createGetNormalizedCreateKey","quote","existingString","normalizedKey","getNormalizedParseKey","cleanKey","slice","parseStringPath","path","results","size","clear","match"],"mappings":"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","sourcesContent":["// constants\nimport { CACHE, DOTTY_WITH_BRACKETS_SYNTAX, MAX_CACHE_SIZE, NUMBER, QUOTED_KEY, VALID_KEY, WHITE_SPACE } from './constants';\n/**\n * @function isNumericKey\n *\n * @description\n * is the key passed a numeric string\n *\n * @param {string} key the key to test\n * @returns {boolean} is the key passed a numeric string\n */\n\nexport var isNumericKey = function isNumericKey(key) {\n  return !!(key && key.length) && NUMBER.test(key);\n};\n/**\n * @function isQuotedKey\n *\n * @description\n * is the key passed a quoted key\n *\n * @param {string} key the key to test\n * @returns {boolean} is the key a quoted key\n */\n\nexport var isQuotedKey = function isQuotedKey(key) {\n  return QUOTED_KEY.test(key);\n};\n/**\n * @function map\n *\n * @description\n * map the array to a new array based on fn\n *\n * @param {Array<*>} array the array to map\n * @param {function} fn the function to call with each iteration value\n * @returns {Array<*>} the mapped array\n */\n\nexport var map = function map(array, fn) {\n  var length = array.length;\n  var mapped = [];\n\n  for (var index = 0; index < length; index++) {\n    mapped[index] = fn(array[index]);\n  }\n\n  return mapped;\n};\n/**\n * @function shouldBeInBrackets\n *\n * @description\n * should the key passed be encased in brackets when in the path string\n *\n * @param {*} key the key that is being added to the path string\n * @returns {boolean} should the key be in brackets\n */\n\nexport var shouldBeInBrackets = function shouldBeInBrackets(key) {\n  return typeof key === 'number' || isNumericKey(key) || isQuotedKey(key);\n};\n/**\n * @function shouldBeInQuotes\n *\n * @description\n * should the key passed be encased in quotes when in the path string\n *\n * @param {*} key the key that is being added to the path string\n * @returns {boolean} should the key be in quotes\n */\n\nexport var shouldBeInQuotes = function shouldBeInQuotes(key) {\n  return WHITE_SPACE.test(key) || !VALID_KEY.test(key);\n};\n/**\n * @function createGetNormalizedCreateKey\n *\n * @description\n * get the normalized path string based on the quote and key passed\n *\n * @param {string} [quote=\"] the quote string to use\n * @returns {function(string, *): string}\n */\n\nexport var createGetNormalizedCreateKey = function createGetNormalizedCreateKey(quote) {\n  return function (existingString, key) {\n    var normalizedKey = shouldBeInQuotes(key) ? \"\" + quote + key + quote : key;\n    return existingString + (shouldBeInBrackets(normalizedKey) ? \"[\" + normalizedKey + \"]\" : \".\" + normalizedKey);\n  };\n};\n/**\n * @function getNormalizedParseKey\n *\n * @description\n * get the key as a number if parseable, or as a quoted string if applicable\n *\n * @param {string} key the key to try to parse\n * @returns {number|string} the parsed key\n */\n\nexport var getNormalizedParseKey = function getNormalizedParseKey(key) {\n  var cleanKey = isQuotedKey(key) ? key.slice(1, key.length - 1) : key;\n  return isNumericKey(cleanKey) ? +cleanKey : cleanKey;\n};\n/**\n * @function parsePath\n *\n * @description\n * parse the path, memoizing the results\n *\n * @param {string} path the path to parse\n * @returns {Array<number|string>} the parsed path\n */\n\nexport var parseStringPath = function parseStringPath(path) {\n  if (CACHE.results[path]) {\n    return CACHE.results[path];\n  }\n\n  if (CACHE.size > MAX_CACHE_SIZE) {\n    CACHE.clear();\n  }\n\n  CACHE.results[path] = path ? map(path.match(DOTTY_WITH_BRACKETS_SYNTAX), getNormalizedParseKey) : [path];\n  CACHE.size++;\n  return CACHE.results[path];\n};"]},"metadata":{},"sourceType":"module"}