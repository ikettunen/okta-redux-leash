{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('curriable'), require('pathington')) : typeof define === 'function' && define.amd ? define(['exports', 'curriable', 'pathington'], factory) : (global = global || self, factory(global.unchanged = {}, global.curriable, global.pathington));\n})(this, function (exports, curriable, pathington) {\n  'use strict';\n  /*! *****************************************************************************\r\n  Copyright (c) Microsoft Corporation. All rights reserved.\r\n  Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n  this file except in compliance with the License. You may obtain a copy of the\r\n  License at http://www.apache.org/licenses/LICENSE-2.0\r\n    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n  MERCHANTABLITY OR NON-INFRINGEMENT.\r\n    See the Apache Version 2.0 License for specific language governing permissions\r\n  and limitations under the License.\r\n  ***************************************************************************** */\n\n  function __spreadArrays() {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n    for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n    return r;\n  } // external dependencies\n\n\n  var O = Object;\n  var create = O.create,\n      getOwnPropertySymbols = O.getOwnPropertySymbols,\n      getPrototypeOf = O.getPrototypeOf,\n      keys = O.keys,\n      propertyIsEnumerable = O.propertyIsEnumerable;\n  var isArray = Array.isArray;\n  var toStringFunction = Function.prototype.bind.call(Function.prototype.call, Function.prototype.toString);\n  var toStringObject = Function.prototype.bind.call(Function.prototype.call, O.prototype.toString);\n  /**\r\n   * @constant HAS_SYMBOL_SUPPORT are Symbols supported\r\n   */\n\n  var HAS_SYMBOL_SUPPORT = typeof Symbol === 'function' && typeof Symbol.for === 'function';\n  /**\r\n   * @constant REACT_ELEMENT the symbol / number specific to react elements\r\n   */\n\n  var REACT_ELEMENT = HAS_SYMBOL_SUPPORT ? Symbol.for('react.element') : 0xeac7;\n  /**\r\n   * @function cloneArray\r\n   *\r\n   * @description\r\n   * clone an array to a new array\r\n   *\r\n   * @param array the array to clone\r\n   * @returns the cloned array\r\n   */\n\n  var cloneArray = function (array) {\n    var Constructor = array.constructor;\n    var cloned = Constructor === Array ? [] : new Constructor();\n\n    for (var index = 0, length_1 = array.length; index < length_1; index++) {\n      cloned[index] = array[index];\n    }\n\n    return cloned;\n  };\n  /**\r\n   * @function reduce\r\n   *\r\n   * @description\r\n   * a targeted reduce method faster than the native\r\n   *\r\n   * @param array the array to reduce\r\n   * @param fn the method to reduce each array value with\r\n   * @param initialValue the initial value of the reduction\r\n   * @returns the reduced value\r\n   */\n\n\n  var reduce = function (array, fn, initialValue) {\n    var value = initialValue;\n\n    for (var index = 0, length_2 = array.length; index < length_2; index++) {\n      value = fn(value, array[index]);\n    }\n\n    return value;\n  };\n  /**\r\n   * @function getOwnProperties\r\n   *\r\n   * @description\r\n   * get the all properties (keys and symbols) of the object passed\r\n   *\r\n   * @param object the object to get the properties of\r\n   * @returns the keys and symbols the object has\r\n   */\n\n\n  var getOwnProperties = function (object) {\n    if (!HAS_SYMBOL_SUPPORT) {\n      return keys(object);\n    }\n\n    var ownSymbols = getOwnPropertySymbols(object);\n\n    if (!ownSymbols.length) {\n      return keys(object);\n    }\n\n    return keys(object).concat(reduce(ownSymbols, function (enumerableSymbols, symbol) {\n      if (propertyIsEnumerable.call(object, symbol)) {\n        enumerableSymbols.push(symbol);\n      }\n\n      return enumerableSymbols;\n    }, []));\n  };\n  /**\r\n   * @function assignFallback\r\n   *\r\n   * @description\r\n   * a targeted fallback if native Object.assign is unavailable\r\n   *\r\n   * @param target the object to shallowly merge into\r\n   * @param source the object to shallowly merge into target\r\n   * @returns the shallowly merged object\r\n   */\n\n\n  var assignFallback = function (target, source) {\n    if (!source) {\n      return target;\n    }\n\n    return reduce(getOwnProperties(source), function (clonedObject, property) {\n      clonedObject[property] = source[property];\n      return clonedObject;\n    }, Object(target));\n  };\n\n  var assign = typeof O.assign === 'function' ? O.assign : assignFallback;\n  /**\r\n   * @function createWithProto\r\n   *\r\n   * @description\r\n   * create a new object with the prototype of the object passed\r\n   *\r\n   * @param object object whose prototype will be the new object's prototype\r\n   * @returns object with the prototype of the one passed\r\n   */\n\n  var createWithProto = function (object) {\n    return create(object.__proto__ || getPrototypeOf(object));\n  };\n  /**\r\n   * @function isCloneable\r\n   *\r\n   * @description\r\n   * is the object passed considered cloneable\r\n   *\r\n   * @param object the object that is being checked for cloneability\r\n   * @returns whether the object can be cloned\r\n   */\n\n\n  var isCloneable = function (object) {\n    if (!object || typeof object !== 'object' || object.$$typeof === REACT_ELEMENT) {\n      return false;\n    }\n\n    var type = toStringObject(object);\n    return type !== '[object Date]' && type !== '[object RegExp]';\n  };\n  /**\r\n   * @function isEmptyPath\r\n   *\r\n   * @description\r\n   * is the path passed an empty path\r\n   *\r\n   * @param path the path to check for emptiness\r\n   * @returns whether the path passed is considered empty\r\n   */\n\n\n  var isEmptyPath = function (path) {\n    return path == null || isArray(path) && !path.length;\n  };\n  /**\r\n   * @function isGlobalConstructor\r\n   *\r\n   * @description\r\n   * is the fn passed a global constructor\r\n   *\r\n   * @param fn the fn to check if a global constructor\r\n   * @returns whether the fn passed is a global constructor\r\n   */\n\n\n  var isGlobalConstructor = function (fn) {\n    return typeof fn === 'function' && !!~toStringFunction(fn).indexOf('[native code]');\n  };\n  /**\r\n   * @function callIfFunction\r\n   *\r\n   * @description\r\n   * if the object passed is a function, call it and return its return, else return undefined\r\n   *\r\n   * @param object the object to call if a function\r\n   * @param context the context to call the function with\r\n   * @param parameters the parameters to call the function with\r\n   * @returns the result of the function call, or undefined\r\n   */\n\n\n  var callIfFunction = function (object, context, parameters) {\n    return typeof object === 'function' ? object.apply(context, parameters) : void 0;\n  };\n  /**\r\n   * @function getNewEmptyChild\r\n   *\r\n   * @description\r\n   * get a new empty child object based on the key passed\r\n   *\r\n   * @param key the key to base the empty child on\r\n   * @returns the empty object the child is built from\r\n   */\n\n\n  var getNewEmptyChild = function (key) {\n    return typeof key === 'number' ? [] : {};\n  };\n  /**\r\n   * @function getNewEmptyObject\r\n   *\r\n   * @description\r\n   * get a new empty object based on the object passed\r\n   *\r\n   * @param object the object to base the empty object on\r\n   * @returns an empty version of the object passed\r\n   */\n\n\n  var getNewEmptyObject = function (object) {\n    return isArray(object) ? [] : {};\n  };\n  /**\r\n   * @function getShallowClone\r\n   *\r\n   * @description\r\n   * create a shallow clone of the object passed, respecting its prototype\r\n   *\r\n   * @param object the object to clone\r\n   * @returns a shallow clone of the object passed\r\n   */\n\n\n  var getShallowClone = function (object) {\n    if (object.constructor === O) {\n      return assign({}, object);\n    }\n\n    if (isArray(object)) {\n      return cloneArray(object);\n    }\n\n    return isGlobalConstructor(object.constructor) ? {} : assign(createWithProto(object), object);\n  };\n  /**\r\n   * @function isSameValueZero\r\n   *\r\n   * @description\r\n   * are the values equal based on SameValueZero\r\n   *\r\n   * @param value1 the first value to test\r\n   * @param value2 the second value to test\r\n   * @returns are the two values passed equal based on SameValueZero\r\n   */\n\n\n  var isSameValueZero = function (value1, value2) {\n    return value1 === value2 || value1 !== value1 && value2 !== value2;\n  };\n  /**\r\n   * @function cloneIfPossible\r\n   *\r\n   * @description\r\n   * clone the object if it can be cloned, otherwise return the object itself\r\n   *\r\n   * @param object the object to clone\r\n   * @returns a cloned version of the object, or the object itself if not cloneable\r\n   */\n\n\n  var cloneIfPossible = function (object) {\n    return isCloneable(object) ? getShallowClone(object) : object;\n  };\n  /**\r\n   * @function getCloneOrEmptyObject\r\n   *\r\n   * @description\r\n   * if the object is cloneable, get a clone of the object, else get a new\r\n   * empty child object based on the key\r\n   *\r\n   * @param object the object to clone\r\n   * @param nextKey the key to base the empty child object on\r\n   * @returns a clone of the object, or an empty child object\r\n   */\n\n\n  var getCloneOrEmptyObject = function (object, nextKey) {\n    return isCloneable(object) ? getShallowClone(object) : getNewEmptyChild(nextKey);\n  };\n  /**\r\n   * @function getCoalescedValue\r\n   *\r\n   * @description\r\n   * return the value if not undefined, otherwise return the fallback value\r\n   *\r\n   * @param value the value to coalesce if undefined\r\n   * @param fallbackValue the value to coalesce to\r\n   * @returns the coalesced value\r\n   */\n\n\n  var getCoalescedValue = function (value, fallbackValue) {\n    return value === void 0 ? fallbackValue : value;\n  };\n  /**\r\n   * @function getParsedPath\r\n   *\r\n   * @description\r\n   * parse the path passed into an array path\r\n   *\r\n   * @param path the path to parse\r\n   * @returns the parsed path\r\n   */\n\n\n  var getParsedPath = function (path) {\n    return isArray(path) ? path : pathington.parse(path);\n  };\n  /**\r\n   * @function getCloneAtPath\r\n   *\r\n   * @description\r\n   * get a new object, cloned at the path specified while leveraging\r\n   * structural sharing for the rest of the properties\r\n   *\r\n   * @param path the path to clone at\r\n   * @param object the object with cloned children at path\r\n   * @param onMatch the method to call once the end of the path is reached\r\n   * @param index the path index\r\n   * @returns the object deeply cloned at the path specified\r\n   */\n\n\n  var getCloneAtPath = function (path, object, onMatch, index) {\n    var key = path[index];\n    var nextIndex = index + 1;\n\n    if (nextIndex === path.length) {\n      onMatch(object, key);\n    } else {\n      object[key] = getCloneAtPath(path, getCloneOrEmptyObject(object[key], path[nextIndex]), onMatch, nextIndex);\n    }\n\n    return object;\n  };\n  /**\r\n   * @function getDeepClone\r\n   *\r\n   * @description\r\n   * get a clone of the object at the path specified\r\n   *\r\n   * @param path the path to clone at\r\n   * @param object the object to clone at the path\r\n   * @param onMatch once a patch match is found, the callback to fire\r\n   * @returns the clone of the object at path specified\r\n   */\n\n\n  var getDeepClone = function (path, object, onMatch) {\n    var parsedPath = getParsedPath(path);\n    var topLevelClone = getCloneOrEmptyObject(object, parsedPath[0]);\n\n    if (parsedPath.length === 1) {\n      onMatch(topLevelClone, parsedPath[0]);\n      return topLevelClone;\n    }\n\n    return getCloneAtPath(parsedPath, topLevelClone, onMatch, 0);\n  };\n  /**\r\n   * @function getMergedObject\r\n   *\r\n   * @description\r\n   * merge the source into the target, either deeply or shallowly\r\n   *\r\n   * @param target the object to merge into\r\n   * @param source the object being merged into the target\r\n   * @param isDeep is the merge a deep merge\r\n   * @returns the merged object\r\n   */\n\n\n  var getMergedObject = function (target, source, isDeep) {\n    var isObject1Array = isArray(target);\n\n    if (isObject1Array !== isArray(source) || !isCloneable(target)) {\n      return cloneIfPossible(source);\n    }\n\n    if (isObject1Array) {\n      return target.concat(source);\n    }\n\n    var targetClone = target.constructor === O || isGlobalConstructor(target.constructor) ? {} : createWithProto(target);\n    return reduce(getOwnProperties(source), function (clone, key) {\n      clone[key] = isDeep && isCloneable(source[key]) ? getMergedObject(target[key], source[key], isDeep) : source[key];\n      return clone;\n    }, assign(targetClone, target));\n  };\n  /**\r\n   * @function getValueAtPath\r\n   *\r\n   * @description\r\n   * get the value at the nested property, or the fallback provided\r\n   *\r\n   * @param path the path to get the value from\r\n   * @param object the object to get the value from at path\r\n   * @param noMatchValue the value returned if no match is found\r\n   * @returns the matching value, or the fallback provided\r\n   */\n\n\n  var getValueAtPath = function (path, object, noMatchValue) {\n    var parsedPath = getParsedPath(path);\n\n    if (parsedPath.length === 1) {\n      return object ? getCoalescedValue(object[parsedPath[0]], noMatchValue) : noMatchValue;\n    }\n\n    var ref = object;\n    var key = parsedPath[0];\n\n    for (var index = 0; index < parsedPath.length - 1; index++) {\n      if (!ref || !ref[key]) {\n        return noMatchValue;\n      }\n\n      ref = ref[key];\n      key = parsedPath[index + 1];\n    }\n\n    return ref ? getCoalescedValue(ref[key], noMatchValue) : noMatchValue;\n  };\n  /**\r\n   * @function getFullPath\r\n   *\r\n   * @description\r\n   * get the path to add to, based on the object and fn passed\r\n   *\r\n   * @param path the path to add to\r\n   * @param object the object traversed by the path\r\n   * @param fn the function to transform the retrieved value with\r\n   * @returns the full path to add to\r\n   */\n\n\n  var getFullPath = function (path, object, fn) {\n    var isPathEmpty = isEmptyPath(path);\n    var valueAtPath = isPathEmpty ? object : fn ? fn(getValueAtPath(path, object)) : getValueAtPath(path, object);\n    return isArray(valueAtPath) ? isArray(path) ? path.concat([valueAtPath.length]) : (isPathEmpty ? '' : path) + \"[\" + valueAtPath.length + \"]\" : path;\n  };\n  /**\r\n   * @function splice\r\n   *\r\n   * @description\r\n   * a faster, more targeted version of the native splice\r\n   *\r\n   * @param array the array to remove the value from\r\n   * @param splicedIndex the index of the value to remove\r\n   */\n\n\n  var splice = function (array, splicedIndex) {\n    if (array.length) {\n      var cutoff = array.length - 1;\n      var index = splicedIndex;\n\n      while (index < cutoff) {\n        array[index] = array[index + 1];\n        ++index;\n      }\n\n      array.length = cutoff;\n    }\n  };\n  /**\r\n   * @function throwInvalidFnError\r\n   *\r\n   * @description\r\n   * throw the TypeError based on the invalid handler\r\n   *\r\n   * @throws\r\n   */\n\n\n  var throwInvalidFnError = function () {\n    throw new TypeError('handler passed is not of type \"function\".');\n  };\n\n  var isArray$1 = Array.isArray;\n  var slice = Function.prototype.bind.call(Function.prototype.call, Array.prototype.slice);\n\n  function createCall(isWithHandler) {\n    if (isWithHandler) {\n      return function callWith(fn, path, parameters, object, context) {\n        if (context === void 0) {\n          context = object;\n        }\n\n        if (typeof fn !== 'function') {\n          throwInvalidFnError();\n        }\n\n        var extraArgs = slice(arguments, 5);\n\n        if (isEmptyPath(path)) {\n          return callIfFunction(fn.apply(void 0, __spreadArrays([object], extraArgs)), context, parameters);\n        }\n\n        var value = getValueAtPath(path, object);\n\n        if (value === void 0) {\n          return;\n        }\n\n        var result = fn.apply(void 0, __spreadArrays([value], extraArgs));\n        return callIfFunction(result, context, parameters);\n      };\n    }\n\n    return function call(path, parameters, object, context) {\n      if (context === void 0) {\n        context = object;\n      }\n\n      var callable = isEmptyPath(path) ? object : getValueAtPath(path, object);\n      return callIfFunction(callable, context, parameters);\n    };\n  }\n\n  function createGet(isWithHandler) {\n    if (isWithHandler) {\n      return function getWith(fn, path, object) {\n        if (typeof fn !== 'function') {\n          throwInvalidFnError();\n        }\n\n        var extraArgs = slice(arguments, 4);\n\n        if (isEmptyPath(path)) {\n          return fn.apply(void 0, __spreadArrays([object], extraArgs));\n        }\n\n        var value = getValueAtPath(path, object);\n        return value === void 0 ? value : fn.apply(void 0, __spreadArrays([value], extraArgs));\n      };\n    }\n\n    return function get(path, object) {\n      return isEmptyPath(path) ? object : getValueAtPath(path, object);\n    };\n  }\n\n  function createGetOr(isWithHandler) {\n    if (isWithHandler) {\n      return function getWithOr(fn, noMatchValue, path, object) {\n        if (typeof fn !== 'function') {\n          throwInvalidFnError();\n        }\n\n        var extraArgs = slice(arguments, 4);\n\n        if (isEmptyPath(path)) {\n          return fn.apply(void 0, __spreadArrays([object], extraArgs));\n        }\n\n        var value = getValueAtPath(path, object);\n        return value === void 0 ? noMatchValue : fn.apply(void 0, __spreadArrays([value], extraArgs));\n      };\n    }\n\n    return function getOr(noMatchValue, path, object) {\n      return isEmptyPath(path) ? object : getValueAtPath(path, object, noMatchValue);\n    };\n  }\n\n  function createHas(isWithHandler) {\n    if (isWithHandler) {\n      return function hasWith(fn, path, object) {\n        if (typeof fn !== 'function') {\n          throwInvalidFnError();\n        }\n\n        var extraArgs = slice(arguments, 3);\n\n        if (isEmptyPath(path)) {\n          return !!fn.apply(void 0, __spreadArrays([object], extraArgs));\n        }\n\n        var value = getValueAtPath(path, object);\n        return value !== void 0 && !!fn.apply(void 0, __spreadArrays([value], extraArgs));\n      };\n    }\n\n    return function has(path, object) {\n      return isEmptyPath(path) ? object != null : getValueAtPath(path, object) !== void 0;\n    };\n  }\n\n  function createIs(isWithHandler) {\n    if (isWithHandler) {\n      return function isWith(fn, path, value, object) {\n        if (typeof fn !== 'function') {\n          throwInvalidFnError();\n        }\n\n        var extraArgs = slice(arguments, 4);\n\n        if (isEmptyPath(path)) {\n          return isSameValueZero(fn.apply(void 0, __spreadArrays([object], extraArgs)), value);\n        }\n\n        return isSameValueZero(fn.apply(void 0, __spreadArrays([getValueAtPath(path, object)], extraArgs)), value);\n      };\n    }\n\n    return function is(path, value, object) {\n      var _path = isEmptyPath(path) ? object : getValueAtPath(path, object);\n\n      return isSameValueZero(_path, value);\n    };\n  }\n\n  function createMerge(isWithHandler, isDeep) {\n    if (isWithHandler) {\n      return function mergeWith(fn, path, object) {\n        if (typeof fn !== 'function') {\n          throwInvalidFnError();\n        }\n\n        var extraArgs = slice(arguments, 3);\n\n        if (!isCloneable(object)) {\n          return fn.apply(void 0, __spreadArrays([object], extraArgs));\n        }\n\n        if (isEmptyPath(path)) {\n          var objectToMerge = fn.apply(void 0, __spreadArrays([object], extraArgs));\n          return objectToMerge ? getMergedObject(object, objectToMerge, isDeep) : object;\n        }\n\n        var hasChanged = false;\n        var result = getDeepClone(path, object, function (ref, key) {\n          var objectToMerge = fn.apply(void 0, __spreadArrays([ref[key]], extraArgs));\n\n          if (objectToMerge) {\n            ref[key] = getMergedObject(ref[key], objectToMerge, isDeep);\n            hasChanged = true;\n          }\n        });\n        return hasChanged ? result : object;\n      };\n    }\n\n    return function merge(path, objectToMerge, object) {\n      if (!isCloneable(object)) {\n        return objectToMerge;\n      }\n\n      return isEmptyPath(path) ? getMergedObject(object, objectToMerge, true) : getDeepClone(path, object, function (ref, key) {\n        ref[key] = getMergedObject(ref[key], objectToMerge, isDeep);\n      });\n    };\n  }\n\n  function createNot(isWithHandler) {\n    var is = createIs(isWithHandler);\n    return function not() {\n      return !is.apply(this, arguments);\n    };\n  }\n\n  function createRemove(isWithHandler) {\n    if (isWithHandler) {\n      return function removeWith(fn, path, object) {\n        if (typeof fn !== 'function') {\n          throwInvalidFnError();\n        }\n\n        var extraArgs = slice(arguments, 3);\n\n        if (isEmptyPath(path)) {\n          var emptyObject = getNewEmptyObject(object);\n          return fn.apply(void 0, __spreadArrays([emptyObject], extraArgs)) ? emptyObject : object;\n        }\n\n        var value = getValueAtPath(path, object);\n        return value !== void 0 && fn.apply(void 0, __spreadArrays([value], extraArgs)) ? getDeepClone(path, object, function (ref, key) {\n          if (isArray$1(ref)) {\n            splice(ref, key);\n          } else {\n            delete ref[key];\n          }\n        }) : object;\n      };\n    }\n\n    return function remove(path, object) {\n      if (isEmptyPath(path)) {\n        return getNewEmptyObject(object);\n      }\n\n      return getValueAtPath(path, object) !== void 0 ? getDeepClone(path, object, function (ref, key) {\n        if (isArray$1(ref)) {\n          splice(ref, key);\n        } else {\n          delete ref[key];\n        }\n      }) : object;\n    };\n  }\n\n  function createSet(isWithHandler) {\n    if (isWithHandler) {\n      return function setWith(fn, path, object) {\n        if (typeof fn !== 'function') {\n          throwInvalidFnError();\n        }\n\n        var extraArgs = slice(arguments, 3);\n        return isEmptyPath(path) ? fn.apply(void 0, __spreadArrays([object], extraArgs)) : getDeepClone(path, object, function (ref, key) {\n          ref[key] = fn.apply(void 0, __spreadArrays([ref[key]], extraArgs));\n        });\n      };\n    }\n\n    return function set(path, value, object) {\n      return isEmptyPath(path) ? value : getDeepClone(path, object, function (ref, key) {\n        ref[key] = value;\n      });\n    };\n  }\n\n  function createAdd(isWithHandler) {\n    var _add = createSet(isWithHandler);\n\n    if (isWithHandler) {\n      return function addWith(fn, path, object) {\n        return _add.apply(this, [fn, getFullPath(path, object, fn), object].concat(slice(arguments, 3)));\n      };\n    }\n\n    return function add(path, value, object) {\n      return _add(getFullPath(path, object), value, object);\n    };\n  } // external dependencies\n\n\n  var add = curriable.curry(createAdd(false));\n  var addWith = curriable.curry(createAdd(true));\n  var assign$1 = curriable.curry(createMerge(false, false));\n  var assignWith = curriable.curry(createMerge(true, false));\n  var call = curriable.curry(createCall(false), 3);\n  var callWith = curriable.curry(createCall(true), 4);\n  var get = curriable.curry(createGet(false));\n  var getOr = curriable.curry(createGetOr(false));\n  var getWith = curriable.curry(createGet(true));\n  var getWithOr = curriable.curry(createGetOr(true));\n  var has = curriable.curry(createHas(false));\n  var hasWith = curriable.curry(createHas(true));\n  var is = curriable.curry(createIs(false));\n  var isWith = curriable.curry(createIs(true));\n  var merge = curriable.curry(createMerge(false, true));\n  var mergeWith = curriable.curry(createMerge(true, true));\n  var not = curriable.curry(createNot(false));\n  var notWith = curriable.curry(createNot(true));\n  var remove = curriable.curry(createRemove(false));\n  var removeWith = curriable.curry(createRemove(true));\n  var set = curriable.curry(createSet(false));\n  var setWith = curriable.curry(createSet(true));\n  Object.defineProperty(exports, '__', {\n    enumerable: true,\n    get: function () {\n      return curriable.__;\n    }\n  });\n  exports.add = add;\n  exports.addWith = addWith;\n  exports.assign = assign$1;\n  exports.assignWith = assignWith;\n  exports.call = call;\n  exports.callWith = callWith;\n  exports.get = get;\n  exports.getOr = getOr;\n  exports.getWith = getWith;\n  exports.getWithOr = getWithOr;\n  exports.has = has;\n  exports.hasWith = hasWith;\n  exports.is = is;\n  exports.isWith = isWith;\n  exports.merge = merge;\n  exports.mergeWith = mergeWith;\n  exports.not = not;\n  exports.notWith = notWith;\n  exports.remove = remove;\n  exports.removeWith = removeWith;\n  exports.set = set;\n  exports.setWith = setWith;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"sources":["../node_modules/tslib/tslib.es6.js","../src/utils.ts","../src/handlers.ts","../src/index.ts"],"names":["parse","isArray","curry","assign"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","// external dependencies\nimport { parse } from 'pathington';\n\nconst O = Object;\nconst { create, getOwnPropertySymbols, getPrototypeOf, keys, propertyIsEnumerable } = O;\n\nconst { isArray } = Array;\n\ntype ToString = (value: any) => string;\n\nconst toStringFunction: ToString = Function.prototype.bind.call(\n  Function.prototype.call,\n  Function.prototype.toString,\n);\nconst toStringObject: ToString = Function.prototype.bind.call(\n  Function.prototype.call,\n  O.prototype.toString,\n);\n\n/**\n * @constant HAS_SYMBOL_SUPPORT are Symbols supported\n */\nconst HAS_SYMBOL_SUPPORT = typeof Symbol === 'function' && typeof Symbol.for === 'function';\n\n/**\n * @constant REACT_ELEMENT the symbol / number specific to react elements\n */\nconst REACT_ELEMENT: symbol | number = HAS_SYMBOL_SUPPORT ? Symbol.for('react.element') : 0xeac7;\n\n/**\n * @function cloneArray\n *\n * @description\n * clone an array to a new array\n *\n * @param array the array to clone\n * @returns the cloned array\n */\nexport const cloneArray = (array: any[]): any[] => {\n  const Constructor = array.constructor as ArrayConstructor;\n  const cloned = Constructor === Array ? [] : new Constructor();\n\n  for (let index = 0, length = array.length; index < length; index++) {\n    cloned[index] = array[index];\n  }\n\n  return cloned;\n};\n\n/**\n * @function reduce\n *\n * @description\n * a targeted reduce method faster than the native\n *\n * @param array the array to reduce\n * @param fn the method to reduce each array value with\n * @param initialValue the initial value of the reduction\n * @returns the reduced value\n */\nexport const reduce = (\n  array: any[],\n  fn: (accum: any, value: any) => any,\n  initialValue: any,\n): any => {\n  let value = initialValue;\n\n  for (let index = 0, length = array.length; index < length; index++) {\n    value = fn(value, array[index]);\n  }\n\n  return value;\n};\n\n/**\n * @function getOwnProperties\n *\n * @description\n * get the all properties (keys and symbols) of the object passed\n *\n * @param object the object to get the properties of\n * @returns the keys and symbols the object has\n */\nexport const getOwnProperties = (object: unchanged.Unchangeable): (string | symbol)[] => {\n  if (!HAS_SYMBOL_SUPPORT) {\n    return keys(object);\n  }\n\n  const ownSymbols: symbol[] = getOwnPropertySymbols(object);\n\n  if (!ownSymbols.length) {\n    return keys(object);\n  }\n\n  return keys(object).concat(\n    reduce(\n      ownSymbols,\n      (enumerableSymbols: symbol[], symbol: symbol): symbol[] => {\n        if (propertyIsEnumerable.call(object, symbol)) {\n          enumerableSymbols.push(symbol);\n        }\n\n        return enumerableSymbols;\n      },\n      [],\n    ),\n  );\n};\n\n/**\n * @function assignFallback\n *\n * @description\n * a targeted fallback if native Object.assign is unavailable\n *\n * @param target the object to shallowly merge into\n * @param source the object to shallowly merge into target\n * @returns the shallowly merged object\n */\nexport const assignFallback = (\n  target: unchanged.Unchangeable,\n  source: unchanged.Unchangeable,\n): unchanged.Unchangeable => {\n  if (!source) {\n    return target;\n  }\n\n  return reduce(\n    getOwnProperties(source),\n    (clonedObject: unchanged.Unchangeable, property: string) => {\n      clonedObject[property] = source[property];\n\n      return clonedObject;\n    },\n    Object(target),\n  );\n};\n\nconst assign = typeof O.assign === 'function' ? O.assign : assignFallback;\n\n/**\n * @function createWithProto\n *\n * @description\n * create a new object with the prototype of the object passed\n *\n * @param object object whose prototype will be the new object's prototype\n * @returns object with the prototype of the one passed\n */\nexport const createWithProto = (object: unchanged.Unchangeable): unchanged.Unchangeable =>\n  create(object.__proto__ || getPrototypeOf(object));\n\n/**\n * @function isCloneable\n *\n * @description\n * is the object passed considered cloneable\n *\n * @param object the object that is being checked for cloneability\n * @returns whether the object can be cloned\n */\nexport const isCloneable = (object: any) => {\n  if (!object || typeof object !== 'object' || object.$$typeof === REACT_ELEMENT) {\n    return false;\n  }\n\n  const type = toStringObject(object);\n\n  return type !== '[object Date]' && type !== '[object RegExp]';\n};\n\n/**\n * @function isEmptyPath\n *\n * @description\n * is the path passed an empty path\n *\n * @param path the path to check for emptiness\n * @returns whether the path passed is considered empty\n */\nexport const isEmptyPath = (path: any) => path == null || (isArray(path) && !path.length);\n\n/**\n * @function isGlobalConstructor\n *\n * @description\n * is the fn passed a global constructor\n *\n * @param fn the fn to check if a global constructor\n * @returns whether the fn passed is a global constructor\n */\nexport const isGlobalConstructor = (fn: any) =>\n  typeof fn === 'function' && !!~toStringFunction(fn).indexOf('[native code]');\n\n/**\n * @function callIfFunction\n *\n * @description\n * if the object passed is a function, call it and return its return, else return undefined\n *\n * @param object the object to call if a function\n * @param context the context to call the function with\n * @param parameters the parameters to call the function with\n * @returns the result of the function call, or undefined\n */\nexport const callIfFunction = (object: any, context: any, parameters: any[]) =>\n  typeof object === 'function' ? object.apply(context, parameters) : void 0;\n\n/**\n * @function getNewEmptyChild\n *\n * @description\n * get a new empty child object based on the key passed\n *\n * @param key the key to base the empty child on\n * @returns the empty object the child is built from\n */\nexport const getNewEmptyChild = (key: any): unchanged.Unchangeable =>\n  typeof key === 'number' ? [] : {};\n\n/**\n * @function getNewEmptyObject\n *\n * @description\n * get a new empty object based on the object passed\n *\n * @param object the object to base the empty object on\n * @returns an empty version of the object passed\n */\nexport const getNewEmptyObject = (object: unchanged.Unchangeable): unchanged.Unchangeable =>\n  isArray(object) ? [] : {};\n\n/**\n * @function getShallowClone\n *\n * @description\n * create a shallow clone of the object passed, respecting its prototype\n *\n * @param object the object to clone\n * @returns a shallow clone of the object passed\n */\nexport const getShallowClone = (object: unchanged.Unchangeable): unchanged.Unchangeable => {\n  if (object.constructor === O) {\n    return assign({}, object);\n  }\n\n  if (isArray(object)) {\n    return cloneArray(object);\n  }\n\n  return isGlobalConstructor(object.constructor) ? {} : assign(createWithProto(object), object);\n};\n\n/**\n * @function isSameValueZero\n *\n * @description\n * are the values equal based on SameValueZero\n *\n * @param value1 the first value to test\n * @param value2 the second value to test\n * @returns are the two values passed equal based on SameValueZero\n */\nexport const isSameValueZero = (value1: any, value2: any) =>\n  value1 === value2 || (value1 !== value1 && value2 !== value2);\n\n/**\n * @function cloneIfPossible\n *\n * @description\n * clone the object if it can be cloned, otherwise return the object itself\n *\n * @param object the object to clone\n * @returns a cloned version of the object, or the object itself if not cloneable\n */\nexport const cloneIfPossible = (object: any) =>\n  isCloneable(object) ? getShallowClone(object) : object;\n\n/**\n * @function getCloneOrEmptyObject\n *\n * @description\n * if the object is cloneable, get a clone of the object, else get a new\n * empty child object based on the key\n *\n * @param object the object to clone\n * @param nextKey the key to base the empty child object on\n * @returns a clone of the object, or an empty child object\n */\nexport const getCloneOrEmptyObject = (\n  object: unchanged.Unchangeable,\n  nextKey: any,\n): unchanged.Unchangeable =>\n  isCloneable(object) ? getShallowClone(object) : getNewEmptyChild(nextKey);\n\n/**\n * @function getCoalescedValue\n *\n * @description\n * return the value if not undefined, otherwise return the fallback value\n *\n * @param value the value to coalesce if undefined\n * @param fallbackValue the value to coalesce to\n * @returns the coalesced value\n */\nexport const getCoalescedValue = (value: any, fallbackValue: any) =>\n  value === void 0 ? fallbackValue : value;\n\n/**\n * @function getParsedPath\n *\n * @description\n * parse the path passed into an array path\n *\n * @param path the path to parse\n * @returns the parsed path\n */\nexport const getParsedPath = (path: unchanged.Path): unchanged.ParsedPath =>\n  isArray(path) ? path : parse(path);\n\n/**\n * @function getCloneAtPath\n *\n * @description\n * get a new object, cloned at the path specified while leveraging\n * structural sharing for the rest of the properties\n *\n * @param path the path to clone at\n * @param object the object with cloned children at path\n * @param onMatch the method to call once the end of the path is reached\n * @param index the path index\n * @returns the object deeply cloned at the path specified\n */\nexport const getCloneAtPath = (\n  path: unchanged.ParsedPath,\n  object: unchanged.Unchangeable,\n  onMatch: (object: unchanged.Unchangeable, key: unchanged.PathItem) => any,\n  index: number,\n) => {\n  const key = path[index];\n  const nextIndex = index + 1;\n\n  if (nextIndex === path.length) {\n    onMatch(object, key);\n  } else {\n    object[key] = getCloneAtPath(\n      path,\n      getCloneOrEmptyObject(object[key], path[nextIndex]),\n      onMatch,\n      nextIndex,\n    );\n  }\n\n  return object;\n};\n\n/**\n * @function getDeepClone\n *\n * @description\n * get a clone of the object at the path specified\n *\n * @param path the path to clone at\n * @param object the object to clone at the path\n * @param onMatch once a patch match is found, the callback to fire\n * @returns the clone of the object at path specified\n */\nexport const getDeepClone = (\n  path: unchanged.Path,\n  object: unchanged.Unchangeable,\n  onMatch: (object: unchanged.Unchangeable, key: unchanged.PathItem) => any,\n): unchanged.Unchangeable => {\n  const parsedPath = getParsedPath(path);\n  const topLevelClone = getCloneOrEmptyObject(object, parsedPath[0]);\n\n  if (parsedPath.length === 1) {\n    onMatch(topLevelClone, parsedPath[0]);\n\n    return topLevelClone;\n  }\n\n  return getCloneAtPath(parsedPath, topLevelClone, onMatch, 0);\n};\n\n/**\n * @function getMergedObject\n *\n * @description\n * merge the source into the target, either deeply or shallowly\n *\n * @param target the object to merge into\n * @param source the object being merged into the target\n * @param isDeep is the merge a deep merge\n * @returns the merged object\n */\nexport const getMergedObject = (\n  target: unchanged.Unchangeable,\n  source: unchanged.Unchangeable,\n  isDeep: boolean,\n): unchanged.Unchangeable => {\n  const isObject1Array: boolean = isArray(target);\n\n  if (isObject1Array !== isArray(source) || !isCloneable(target)) {\n    return cloneIfPossible(source);\n  }\n\n  if (isObject1Array) {\n    return target.concat(source);\n  }\n\n  const targetClone: unchanged.Unchangeable =\n    target.constructor === O || isGlobalConstructor(target.constructor)\n      ? {}\n      : createWithProto(target);\n\n  return reduce(\n    getOwnProperties(source),\n    (clone: unchanged.Unchangeable, key: string): unchanged.Unchangeable => {\n      clone[key] =\n        isDeep && isCloneable(source[key])\n          ? getMergedObject(target[key], source[key], isDeep)\n          : source[key];\n\n      return clone;\n    },\n    assign(targetClone, target),\n  );\n};\n\n/**\n * @function getValueAtPath\n *\n * @description\n * get the value at the nested property, or the fallback provided\n *\n * @param path the path to get the value from\n * @param object the object to get the value from at path\n * @param noMatchValue the value returned if no match is found\n * @returns the matching value, or the fallback provided\n */\nexport const getValueAtPath = (\n  path: unchanged.Path,\n  object: unchanged.Unchangeable,\n  noMatchValue?: any,\n) => {\n  const parsedPath = getParsedPath(path);\n\n  if (parsedPath.length === 1) {\n    return object ? getCoalescedValue(object[parsedPath[0]], noMatchValue) : noMatchValue;\n  }\n\n  let ref: any = object;\n  let key: number | string = parsedPath[0];\n\n  for (let index: number = 0; index < parsedPath.length - 1; index++) {\n    if (!ref || !ref[key]) {\n      return noMatchValue;\n    }\n\n    ref = ref[key];\n    key = parsedPath[index + 1];\n  }\n\n  return ref ? getCoalescedValue(ref[key], noMatchValue) : noMatchValue;\n};\n\n/**\n * @function getFullPath\n *\n * @description\n * get the path to add to, based on the object and fn passed\n *\n * @param path the path to add to\n * @param object the object traversed by the path\n * @param fn the function to transform the retrieved value with\n * @returns the full path to add to\n */\nexport const getFullPath = (\n  path: unchanged.Path,\n  object: unchanged.Unchangeable,\n  fn?: (value: any) => any,\n): unchanged.Path => {\n  const isPathEmpty: boolean = isEmptyPath(path);\n  const valueAtPath: any = isPathEmpty\n    ? object\n    : fn\n    ? fn(getValueAtPath(path, object))\n    : getValueAtPath(path, object);\n\n  return isArray(valueAtPath)\n    ? isArray(path)\n      ? path.concat([valueAtPath.length])\n      : `${isPathEmpty ? '' : path}[${valueAtPath.length}]`\n    : path;\n};\n\n/**\n * @function splice\n *\n * @description\n * a faster, more targeted version of the native splice\n *\n * @param array the array to remove the value from\n * @param splicedIndex the index of the value to remove\n */\nexport const splice = (array: any[], splicedIndex: number): void => {\n  if (array.length) {\n    const cutoff = array.length - 1;\n\n    let index = splicedIndex;\n\n    while (index < cutoff) {\n      array[index] = array[index + 1];\n\n      ++index;\n    }\n\n    array.length = cutoff;\n  }\n};\n\n/**\n * @function throwInvalidFnError\n *\n * @description\n * throw the TypeError based on the invalid handler\n *\n * @throws\n */\nexport const throwInvalidFnError = (): never => {\n  throw new TypeError('handler passed is not of type \"function\".');\n};\n","// utils\nimport {\n  callIfFunction,\n  getDeepClone,\n  getFullPath,\n  getMergedObject,\n  getValueAtPath,\n  getNewEmptyObject,\n  isCloneable,\n  isEmptyPath,\n  isSameValueZero,\n  splice,\n  throwInvalidFnError,\n} from './utils';\n\nconst { isArray } = Array;\nconst slice = Function.prototype.bind.call(Function.prototype.call, Array.prototype.slice);\n\n/**\n * @function createCall\n *\n * @description\n * create handlers for call / callWith\n *\n * @param isWithHandler is the method using a with handler\n * @returns call / callWith\n */\nexport function createCall<IsWith extends true | false>(\n  isWithHandler: IsWith,\n): IsWith extends true ? unchanged.CallWith : unchanged.Call;\nexport function createCall<IsWith extends true | false>(\n  isWithHandler: IsWith,\n): unchanged.CallWith | unchanged.Call {\n  if (isWithHandler) {\n    return function callWith(\n      fn: unchanged.WithHandler,\n      path: unchanged.Path,\n      parameters: any[],\n      object: unchanged.Unchangeable | unchanged.Fn,\n      context: any = object,\n    ) {\n      if (typeof fn !== 'function') {\n        throwInvalidFnError();\n      }\n\n      const extraArgs: any[] = slice(arguments, 5);\n\n      if (isEmptyPath(path)) {\n        return callIfFunction(fn(object, ...extraArgs), context, parameters);\n      }\n\n      const value = getValueAtPath(path, object);\n\n      if (value === void 0) {\n        return;\n      }\n\n      const result = fn(value, ...extraArgs);\n\n      return callIfFunction(result, context, parameters);\n    };\n  }\n\n  return function call(\n    path: unchanged.Path,\n    parameters: any[],\n    object: unchanged.Unchangeable | Function,\n    context: any = object,\n  ) {\n    const callable = isEmptyPath(path) ? object : getValueAtPath(path, object);\n\n    return callIfFunction(callable, context, parameters);\n  };\n}\n\n/**\n * @function createGet\n *\n * @description\n * create handlers for get / getWith\n *\n * @param isWithHandler is the method using a with handler\n * @returns get / getWith\n */\nexport function createGet<IsWith extends true | false>(\n  isWithHandler: IsWith,\n): IsWith extends true ? unchanged.GetWith : unchanged.Get;\nexport function createGet<IsWith extends true | false>(\n  isWithHandler: IsWith,\n): unchanged.GetWith | unchanged.Get {\n  if (isWithHandler) {\n    return function getWith(\n      fn: unchanged.WithHandler,\n      path: unchanged.Path,\n      object: unchanged.Unchangeable,\n    ) {\n      if (typeof fn !== 'function') {\n        throwInvalidFnError();\n      }\n\n      const extraArgs: any[] = slice(arguments, 4);\n\n      if (isEmptyPath(path)) {\n        return fn(object, ...extraArgs);\n      }\n\n      const value = getValueAtPath(path, object);\n\n      return value === void 0 ? value : fn(value, ...extraArgs);\n    };\n  }\n\n  return function get(path: unchanged.Path, object: unchanged.Unchangeable) {\n    return isEmptyPath(path) ? object : getValueAtPath(path, object);\n  };\n}\n\n/**\n * @function createGetOr\n *\n * @description\n * create handlers for getOr / getWithOr\n *\n * @param isWithHandler is the method using a with handler\n * @returns getOr / getWithOr\n */\nexport function createGetOr<IsWith extends true | false>(\n  isWithHandler: IsWith,\n): IsWith extends true ? unchanged.GetWithOr : unchanged.GetOr;\nexport function createGetOr<IsWith extends true | false>(\n  isWithHandler: IsWith,\n): unchanged.GetWithOr | unchanged.GetOr {\n  if (isWithHandler) {\n    return function getWithOr(\n      fn: unchanged.WithHandler,\n      noMatchValue: any,\n      path: unchanged.Path,\n      object: unchanged.Unchangeable,\n    ) {\n      if (typeof fn !== 'function') {\n        throwInvalidFnError();\n      }\n\n      const extraArgs: any[] = slice(arguments, 4);\n\n      if (isEmptyPath(path)) {\n        return fn(object, ...extraArgs);\n      }\n\n      const value = getValueAtPath(path, object);\n\n      return value === void 0 ? noMatchValue : fn(value, ...extraArgs);\n    };\n  }\n\n  return function getOr(noMatchValue: any, path: unchanged.Path, object: unchanged.Unchangeable) {\n    return isEmptyPath(path) ? object : getValueAtPath(path, object, noMatchValue);\n  };\n}\n\n/**\n * @function createHas\n *\n * @description\n * create handlers for has / hasWith\n *\n * @param isWithHandler is the method using a with handler\n * @returns has / hasWith\n */\nexport function createHas<IsWith extends true | false>(\n  isWithHandler: IsWith,\n): IsWith extends true ? unchanged.HasWith : unchanged.Has;\nexport function createHas<IsWith extends true | false>(\n  isWithHandler: IsWith,\n): unchanged.HasWith | unchanged.Has {\n  if (isWithHandler) {\n    return function hasWith(\n      fn: unchanged.WithHandler,\n      path: unchanged.Path,\n      object: unchanged.Unchangeable,\n    ) {\n      if (typeof fn !== 'function') {\n        throwInvalidFnError();\n      }\n\n      const extraArgs: any[] = slice(arguments, 3);\n\n      if (isEmptyPath(path)) {\n        return !!fn(object, ...extraArgs);\n      }\n\n      const value: any = getValueAtPath(path, object);\n\n      return value !== void 0 && !!fn(value, ...extraArgs);\n    };\n  }\n\n  return function has(path: unchanged.Path, object: unchanged.Unchangeable) {\n    return isEmptyPath(path) ? object != null : getValueAtPath(path, object) !== void 0;\n  };\n}\n\n/**\n * @function createIs\n *\n * @description\n * create handlers for is / isWith\n *\n * @param isWithHandler is the method using a with handler\n * @returns is / isWith\n */\nexport function createIs<IsWith extends true | false>(\n  isWithHandler: IsWith,\n): IsWith extends true ? unchanged.IsWith : unchanged.Is;\nexport function createIs<IsWith extends true | false>(\n  isWithHandler: IsWith,\n): unchanged.IsWith | unchanged.Is {\n  if (isWithHandler) {\n    return function isWith(\n      fn: unchanged.WithHandler,\n      path: unchanged.Path,\n      value: any,\n      object: unchanged.Unchangeable,\n    ) {\n      if (typeof fn !== 'function') {\n        throwInvalidFnError();\n      }\n\n      const extraArgs: any[] = slice(arguments, 4);\n\n      if (isEmptyPath(path)) {\n        return isSameValueZero(fn(object, ...extraArgs), value);\n      }\n\n      return isSameValueZero(fn(getValueAtPath(path, object), ...extraArgs), value);\n    };\n  }\n\n  return function is(path: unchanged.Path, value: any, object: unchanged.Unchangeable) {\n    const _path = isEmptyPath(path) ? object : getValueAtPath(path, object);\n\n    return isSameValueZero(_path, value);\n  };\n}\n\n/**\n * @function createMerge\n *\n * @description\n * create handlers for merge / mergeWith\n *\n * @param isWithHandler is the method using a with handler\n * @param isDeep is the handler for a deep merge or shallow\n * @returns merge / mergeWith\n */\nexport function createMerge<IsWith extends true | false>(\n  isWithHandler: IsWith,\n  isDeep: boolean,\n): IsWith extends true ? unchanged.MergeWith : unchanged.Merge;\nexport function createMerge<IsWith extends true | false>(\n  isWithHandler: IsWith,\n  isDeep: boolean,\n): unchanged.MergeWith | unchanged.Merge {\n  if (isWithHandler) {\n    return function mergeWith(\n      fn: unchanged.WithHandler,\n      path: unchanged.Path,\n      object: unchanged.Unchangeable,\n    ): unchanged.Unchangeable {\n      if (typeof fn !== 'function') {\n        throwInvalidFnError();\n      }\n\n      const extraArgs: any[] = slice(arguments, 3);\n\n      if (!isCloneable(object)) {\n        return fn(object, ...extraArgs);\n      }\n\n      if (isEmptyPath(path)) {\n        const objectToMerge: any = fn(object, ...extraArgs);\n\n        return objectToMerge ? getMergedObject(object, objectToMerge, isDeep) : object;\n      }\n\n      let hasChanged: boolean = false;\n\n      const result: unchanged.Unchangeable = getDeepClone(\n        path,\n        object,\n        (ref: unchanged.Unchangeable, key: unchanged.PathItem): void => {\n          const objectToMerge: any = fn(ref[key], ...extraArgs);\n\n          if (objectToMerge) {\n            ref[key] = getMergedObject(ref[key], objectToMerge, isDeep);\n\n            hasChanged = true;\n          }\n        },\n      );\n\n      return hasChanged ? result : object;\n    };\n  }\n\n  return function merge(\n    path: unchanged.Path,\n    objectToMerge: unchanged.Unchangeable,\n    object: unchanged.Unchangeable,\n  ): unchanged.Unchangeable {\n    if (!isCloneable(object)) {\n      return objectToMerge;\n    }\n\n    return isEmptyPath(path)\n      ? getMergedObject(object, objectToMerge, true)\n      : getDeepClone(path, object, (ref: unchanged.Unchangeable, key: unchanged.PathItem): void => {\n        ref[key] = getMergedObject(ref[key], objectToMerge, isDeep);\n      });\n  };\n}\n\n/**\n * @function createNot\n *\n * @description\n * create handlers for not / notWith\n *\n * @param isWithHandler not the method using a with handler\n * @returns not / notWithHandler\n */\nexport function createNot<IsWith extends true | false>(\n  isWithHandler: IsWith,\n): IsWith extends true ? unchanged.NotWith : unchanged.Not;\nexport function createNot<IsWith extends true | false>(\n  isWithHandler: IsWith,\n): unchanged.NotWith | unchanged.Not {\n  const is: Function = createIs(isWithHandler);\n\n  return function not(this: any) {\n    return !is.apply(this, arguments);\n  };\n}\n\n/**\n * @function createRemove\n *\n * @description\n * create handlers for remove / removeWith\n *\n * @param isWithHandler is the method using a with handler\n * @returns remove / removeWith\n */\nexport function createRemove<IsWith extends true | false>(\n  isWithHandler: IsWith,\n): IsWith extends true ? unchanged.RemoveWith : unchanged.Remove;\nexport function createRemove<IsWith extends true | false>(\n  isWithHandler: IsWith,\n): unchanged.RemoveWith | unchanged.Remove {\n  if (isWithHandler) {\n    return function removeWith(\n      fn: unchanged.WithHandler,\n      path: unchanged.Path,\n      object: unchanged.Unchangeable,\n    ): unchanged.Unchangeable {\n      if (typeof fn !== 'function') {\n        throwInvalidFnError();\n      }\n\n      const extraArgs: any[] = slice(arguments, 3);\n\n      if (isEmptyPath(path)) {\n        const emptyObject: unchanged.Unchangeable = getNewEmptyObject(object);\n\n        return fn(emptyObject, ...extraArgs) ? emptyObject : object;\n      }\n\n      const value: any = getValueAtPath(path, object);\n\n      return value !== void 0 && fn(value, ...extraArgs)\n        ? getDeepClone(path, object, (ref: unchanged.Unchangeable, key: number | string): void => {\n          if (isArray(ref)) {\n            splice(ref, key as number);\n          } else {\n            delete ref[key];\n          }\n        })\n        : object;\n    };\n  }\n\n  return function remove(\n    path: unchanged.Path,\n    object: unchanged.Unchangeable,\n  ): unchanged.Unchangeable {\n    if (isEmptyPath(path)) {\n      return getNewEmptyObject(object);\n    }\n\n    return getValueAtPath(path, object) !== void 0\n      ? getDeepClone(path, object, (ref: unchanged.Unchangeable, key: number | string): void => {\n        if (isArray(ref)) {\n          splice(ref, key as number);\n        } else {\n          delete ref[key];\n        }\n      })\n      : object;\n  };\n}\n\n/**\n * @function createSet\n *\n * @description\n * create handlers for set / setWith\n *\n * @param isWithHandler is the method using a with handler\n * @returns set / setWith\n */\nexport function createSet<IsWith extends true | false>(\n  isWithHandler: IsWith,\n): IsWith extends true ? unchanged.SetWith : unchanged.Set;\nexport function createSet<IsWith extends true | false>(\n  isWithHandler: IsWith,\n): unchanged.SetWith | unchanged.Set {\n  if (isWithHandler) {\n    return function setWith(\n      fn: unchanged.WithHandler,\n      path: unchanged.Path,\n      object: unchanged.Unchangeable,\n    ): unchanged.Unchangeable {\n      if (typeof fn !== 'function') {\n        throwInvalidFnError();\n      }\n\n      const extraArgs: any[] = slice(arguments, 3);\n\n      return isEmptyPath(path)\n        ? fn(object, ...extraArgs)\n        : getDeepClone(\n            path,\n            object,\n            (ref: unchanged.Unchangeable, key: unchanged.PathItem): void => {\n              ref[key] = fn(ref[key], ...extraArgs);\n            },\n          );\n    };\n  }\n\n  return function set(\n    path: unchanged.Path,\n    value: any,\n    object: unchanged.Unchangeable,\n  ): unchanged.Unchangeable {\n    return isEmptyPath(path)\n      ? value\n      : getDeepClone(path, object, (ref: unchanged.Unchangeable, key: unchanged.PathItem): void => {\n        ref[key] = value;\n      });\n  };\n}\n\n/**\n * @function createAdd\n *\n * @description\n * create handlers for add / addWith\n *\n * @param isWithHandler is the method using a with handler\n * @returns add / addWith\n */\nexport function createAdd<IsWith extends true | false>(\n  isWithHandler: IsWith,\n): IsWith extends true ? unchanged.AddWith : unchanged.Add;\nexport function createAdd<IsWith extends true | false>(\n  isWithHandler: IsWith,\n): unchanged.AddWith | unchanged.Add {\n  const _add: Function = createSet(isWithHandler);\n\n  if (isWithHandler) {\n    return function addWith(\n      this: any,\n      fn: unchanged.WithHandler,\n      path: unchanged.Path,\n      object: unchanged.Unchangeable,\n    ): unchanged.Unchangeable {\n      return _add.apply(\n        this,\n        [fn, getFullPath(path, object, fn), object].concat(slice(arguments, 3)),\n      );\n    };\n  }\n\n  return function add(\n    path: unchanged.Path,\n    value: any,\n    object: unchanged.Unchangeable,\n  ): unchanged.Unchangeable {\n    return _add(getFullPath(path, object), value, object);\n  };\n}\n","// external dependencies\nimport { Curried, __, curry } from 'curriable';\n\n// handlers\nimport {\n  createAdd,\n  createCall,\n  createGet,\n  createGetOr,\n  createHas,\n  createIs,\n  createMerge,\n  createNot,\n  createRemove,\n  createSet,\n} from './handlers';\n\nexport { __ };\n\nexport const add = curry(createAdd(false));\n\nexport const addWith = curry(createAdd(true));\n\nexport const assign = curry(createMerge(false, false));\n\nexport const assignWith = curry(createMerge(true, false));\n\nexport const call = curry(createCall(false), 3) as Curried<unchanged.Call>;\n\nexport const callWith = curry(createCall(true), 4) as Curried<unchanged.CallWith>;\n\nexport const get = curry(createGet(false));\n\nexport const getOr = curry(createGetOr(false));\n\nexport const getWith = curry(createGet(true));\n\nexport const getWithOr = curry(createGetOr(true));\n\nexport const has = curry(createHas(false));\n\nexport const hasWith = curry(createHas(true));\n\nexport const is = curry(createIs(false));\n\nexport const isWith = curry(createIs(true));\n\nexport const merge = curry(createMerge(false, true));\n\nexport const mergeWith = curry(createMerge(true, true));\n\nexport const not = curry(createNot(false));\n\nexport const notWith = curry(createNot(true));\n\nexport const remove = curry(createRemove(false));\n\nexport const removeWith = curry(createRemove(true));\n\nexport const set = curry(createSet(false));\n\nexport const setWith = curry(createSet(true));\n"]},"metadata":{},"sourceType":"script"}