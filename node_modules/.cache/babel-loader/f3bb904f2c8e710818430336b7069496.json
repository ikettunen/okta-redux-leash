{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = global || self, factory(global.curriable = {}));\n})(this, function (exports) {\n  'use strict';\n  /**\r\n   * @constant __ placeholder used when parameters are skipped\r\n   */\n\n  var __ = typeof Symbol === 'function' ? Symbol('curriable placeholder') : 0xedd1;\n  /**\r\n   * @function recursiveCurry\r\n   *\r\n   * @description\r\n   * recursively curry over the arguments until all have been resolved\r\n   *\r\n   * @param fn the function to curry\r\n   * @param arity the length of the function to curry until\r\n   * @param args the existing arguments\r\n   * @returns the result of the function call\r\n   */\n\n\n  function getCurried(fn, arity) {\n    function _curried(args) {\n      return function () {\n        var length = args.length;\n        var newArgs = arguments;\n        var newArgsLength = newArgs.length;\n        var combined = [];\n        var newArgsIndex = 0;\n        var remaining = arity;\n        var value;\n\n        if (length) {\n          var index = -1;\n\n          while (++index < length) {\n            combined[index] = value = args[index] === __ && newArgsIndex < newArgsLength ? newArgs[newArgsIndex++] : args[index];\n\n            if (value !== __) {\n              --remaining;\n            }\n          }\n        }\n\n        if (newArgsIndex < newArgsLength) {\n          while (newArgsIndex < newArgsLength) {\n            combined[combined.length] = value = newArgs[newArgsIndex];\n\n            if (value !== __ && newArgsIndex < arity) {\n              --remaining;\n            }\n\n            ++newArgsIndex;\n          }\n        }\n\n        return remaining > 0 ? _curried(combined) : fn.apply(this, combined);\n      };\n    }\n\n    return _curried([]);\n  } // utils\n\n\n  function curry(fn, arityOverride) {\n    var arity = typeof arityOverride === 'number' ? arityOverride : fn.length;\n    var curried = getCurried(fn, arity);\n    curried.arity = arity;\n    curried.fn = fn;\n    return curried;\n  }\n\n  curry.__ = __;\n  /**\r\n   * @function isPlaceholder\r\n   *\r\n   * @description\r\n   * is the value passed a placeholder\r\n   *\r\n   * @param value the value to test\r\n   * @returns whether the value is a placeholder\r\n   */\n\n  function isPlaceholder(value) {\n    return value === __;\n  }\n\n  curry.isPlaceholder = isPlaceholder;\n  /**\r\n   * @function uncurry\r\n   *\r\n   * @description\r\n   * return a function that is the non-curried version of the fn passed\r\n   *\r\n   * @param curried the curried function to uncurry\r\n   * @returns the original fn\r\n   */\n\n  function uncurry(curried) {\n    return curried.fn;\n  }\n\n  curry.uncurry = uncurry;\n  exports.__ = __;\n  exports.curry = curry;\n  exports.default = curry;\n  exports.isPlaceholder = isPlaceholder;\n  exports.uncurry = uncurry;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"sources":["../src/utils.ts","../src/index.ts"],"names":[],"mappings":";;;;AAAA;;;;AAGA,MAAa,EAAE,GACb,OAAO,MAAP,KAAkB,UAAlB,GAA+B,MAAM,CAAC,uBAAD,CAArC,GAAiE,MADnE;AAGA;;;;;;;;;;;;;AAWA,WAAgB,UAAhB,CAA+C,EAA/C,EAAuD,KAAvD,EAAoE;AAClE,aAAS,QAAT,CAAkB,IAAlB,EAA6B;AAC3B,aAAO,YAAA;AACL,YAAM,MAAM,GAAW,IAAI,CAAC,MAA5B;AAEA,YAAM,OAAO,GAAe,SAA5B;AACQ,YAAA,aAAA,GAAA,OAAA,CAAA,MAAA;AAER,YAAM,QAAQ,GAAU,EAAxB;AAEA,YAAI,YAAY,GAAG,CAAnB;AACA,YAAI,SAAS,GAAG,KAAhB;AACA,YAAI,KAAJ;;AAEA,YAAI,MAAJ,EAAY;AACV,cAAI,KAAK,GAAG,CAAC,CAAb;;AAEA,iBAAO,EAAE,KAAF,GAAU,MAAjB,EAAyB;AACvB,YAAA,QAAQ,CAAC,KAAD,CAAR,GAAkB,KAAK,GACrB,IAAI,CAAC,KAAD,CAAJ,KAAgB,EAAhB,IAAsB,YAAY,GAAG,aAArC,GACI,OAAO,CAAC,YAAY,EAAb,CADX,GAEI,IAAI,CAAC,KAAD,CAHV;;AAKA,gBAAI,KAAK,KAAK,EAAd,EAAkB;AAChB,gBAAE,SAAF;AACD;AACF;AACF;;AAED,YAAI,YAAY,GAAG,aAAnB,EAAkC;AAChC,iBAAO,YAAY,GAAG,aAAtB,EAAqC;AACnC,YAAA,QAAQ,CAAC,QAAQ,CAAC,MAAV,CAAR,GAA4B,KAAK,GAAG,OAAO,CAAC,YAAD,CAA3C;;AAEA,gBAAI,KAAK,KAAK,EAAV,IAAgB,YAAY,GAAG,KAAnC,EAA0C;AACxC,gBAAE,SAAF;AACD;;AAED,cAAE,YAAF;AACD;AACF;;AAED,eAAO,SAAS,GAAG,CAAZ,GAAgB,QAAQ,CAAC,QAAD,CAAxB,GAAqC,EAAE,CAAC,KAAH,CAAS,IAAT,EAAe,QAAf,CAA5C;AACD,OAxCD;AAyCD;;AAED,WAAO,QAAQ,CAAC,EAAD,CAAf;AACD,G,CC/DD;;;AACA,WAgBgB,KAhBhB,CAgB0C,EAhB1C,EAgBkD,aAhBlD,EAgBwE;AACtE,QAAM,KAAK,GAAG,OAAO,aAAP,KAAyB,QAAzB,GAAoC,aAApC,GAAoD,EAAE,CAAC,MAArE;AACA,QAAM,OAAO,GAAG,UAAU,CAAC,EAAD,EAAK,KAAL,CAA1B;AAEA,IAAA,OAAO,CAAC,KAAR,GAAgB,KAAhB;AACA,IAAA,OAAO,CAAC,EAAR,GAAa,EAAb;AAEA,WAAO,OAAP;AACD;;AAED,EAAA,KAAK,CAAC,EAAN,GAAW,EAAX;AAEA;;;;;;;;;;AASA,WAAgB,aAAhB,CAA8B,KAA9B,EAAwC;AACtC,WAAO,KAAK,KAAK,EAAjB;AACD;;AAED,EAAA,KAAK,CAAC,aAAN,GAAsB,aAAtB;AAEA;;;;;;;;;;AASA,WAAgB,OAAhB,CAA4C,OAA5C,EAAgE;AAC9D,WAAO,OAAO,CAAC,EAAf;AACD;;AAED,EAAA,KAAK,CAAC,OAAN,GAAgB,OAAhB","sourcesContent":["/**\n * @constant __ placeholder used when parameters are skipped\n */\nexport const __: Placeholder =\n  typeof Symbol === 'function' ? Symbol('curriable placeholder') : 0xedd1;\n\n/**\n * @function recursiveCurry\n *\n * @description\n * recursively curry over the arguments until all have been resolved\n *\n * @param fn the function to curry\n * @param arity the length of the function to curry until\n * @param args the existing arguments\n * @returns the result of the function call\n */\nexport function getCurried<Fn extends Handler>(fn: Fn, arity: number): Curry<Fn> {\n  function _curried(args: any[]) {\n    return function () {\n      const length: number = args.length;\n\n      const newArgs: IArguments = arguments;\n      const { length: newArgsLength } = newArgs;\n\n      const combined: any[] = [];\n\n      let newArgsIndex = 0;\n      let remaining = arity;\n      let value: any;\n\n      if (length) {\n        let index = -1;\n\n        while (++index < length) {\n          combined[index] = value =\n            args[index] === __ && newArgsIndex < newArgsLength\n              ? newArgs[newArgsIndex++]\n              : args[index];\n\n          if (value !== __) {\n            --remaining;\n          }\n        }\n      }\n\n      if (newArgsIndex < newArgsLength) {\n        while (newArgsIndex < newArgsLength) {\n          combined[combined.length] = value = newArgs[newArgsIndex];\n\n          if (value !== __ && newArgsIndex < arity) {\n            --remaining;\n          }\n\n          ++newArgsIndex;\n        }\n      }\n\n      return remaining > 0 ? _curried(combined) : fn.apply(this, combined);\n    };\n  }\n\n  return _curried([]);\n}\n","// utils\nimport { __, getCurried } from './utils';\n\nexport { __ };\n\n/**\n * @function curry\n *\n * @description\n * get the method passed as a curriable method based on its parameters\n *\n * @param fn the method to make curriable\n * @param arityOverride the hard-coded arity of the curried method\n * @returns the fn passed as a curried function\n */\nexport function curry<Fn extends Handler>(fn: Fn): Curried<Fn>;\nexport function curry<Fn extends Handler>(fn: Fn, arityOverride: number): Handler;\nexport function curry<Fn extends Handler>(fn: Fn, arityOverride?: number) {\n  const arity = typeof arityOverride === 'number' ? arityOverride : fn.length;\n  const curried = getCurried(fn, arity) as Curried<Fn>;\n\n  curried.arity = arity;\n  curried.fn = fn;\n\n  return curried;\n}\n\ncurry.__ = __;\n\n/**\n * @function isPlaceholder\n *\n * @description\n * is the value passed a placeholder\n *\n * @param value the value to test\n * @returns whether the value is a placeholder\n */\nexport function isPlaceholder(value: any): value is Placeholder {\n  return value === __;\n}\n\ncurry.isPlaceholder = isPlaceholder;\n\n/**\n * @function uncurry\n *\n * @description\n * return a function that is the non-curried version of the fn passed\n *\n * @param curried the curried function to uncurry\n * @returns the original fn\n */\nexport function uncurry<Fn extends Handler>(curried: Curried<Fn>): Fn {\n  return curried.fn;\n}\n\ncurry.uncurry = uncurry;\n\nexport default curry;\n"]},"metadata":{},"sourceType":"script"}