{"ast":null,"code":"// constants\nimport { VALID_QUOTES } from './constants'; // utils\n\nimport { createGetNormalizedCreateKey, getNormalizedParseKey, map, parseStringPath } from './utils';\nvar isArray = Array.isArray;\n/**\n * @function create\n *\n * @description\n * create a new path string based on the path and quote passed\n *\n * @param {Array<number|string>} path the path to convert to a string\n * @param {string} [quote=\"] the quote string to use when quoting keys\n * @returns {string} the path string\n */\n\nexport var create = function create(path, quote) {\n  if (quote === void 0) {\n    quote = '\"';\n  }\n\n  if (!isArray(path)) {\n    throw new ReferenceError('path passed must be an array');\n  }\n\n  if (!VALID_QUOTES.test(quote)) {\n    throw new SyntaxError(\"quote \" + quote + \" passed is invalid, must be \\\", `, or '.\");\n  }\n\n  var pathString = path.reduce(createGetNormalizedCreateKey(quote), '');\n  return pathString[0] === '.' ? pathString.slice(1) : pathString;\n};\n/**\n * @function parse\n *\n * @description\n * the path parsed into a valid array of keys / indices\n *\n * @param {Array<number|string>|number|string} path the path to parse\n * @returns {Array<number|string>} the parsed path\n */\n\nexport var parse = function parse(path) {\n  if (typeof path === 'string') {\n    return parseStringPath(path);\n  }\n\n  if (isArray(path)) {\n    return map(path, getNormalizedParseKey);\n  }\n\n  var normalizedParseKey = getNormalizedParseKey(path);\n  return [typeof normalizedParseKey === 'number' ? normalizedParseKey : \"\" + normalizedParseKey];\n};","map":{"version":3,"sources":["/home/ilkka/okta-redux-leash/node_modules/pathington/es/index.js"],"names":["VALID_QUOTES","createGetNormalizedCreateKey","getNormalizedParseKey","map","parseStringPath","isArray","Array","create","path","quote","ReferenceError","test","SyntaxError","pathString","reduce","slice","parse","normalizedParseKey"],"mappings":"AAAA;AACA,SAASA,YAAT,QAA6B,aAA7B,C,CAA4C;;AAE5C,SAASC,4BAAT,EAAuCC,qBAAvC,EAA8DC,GAA9D,EAAmEC,eAAnE,QAA0F,SAA1F;AACA,IAAIC,OAAO,GAAGC,KAAK,CAACD,OAApB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,IAAIE,MAAM,GAAG,SAASA,MAAT,CAAgBC,IAAhB,EAAsBC,KAAtB,EAA6B;AAC/C,MAAIA,KAAK,KAAK,KAAK,CAAnB,EAAsB;AACpBA,IAAAA,KAAK,GAAG,GAAR;AACD;;AAED,MAAI,CAACJ,OAAO,CAACG,IAAD,CAAZ,EAAoB;AAClB,UAAM,IAAIE,cAAJ,CAAmB,8BAAnB,CAAN;AACD;;AAED,MAAI,CAACV,YAAY,CAACW,IAAb,CAAkBF,KAAlB,CAAL,EAA+B;AAC7B,UAAM,IAAIG,WAAJ,CAAgB,WAAWH,KAAX,GAAmB,0CAAnC,CAAN;AACD;;AAED,MAAII,UAAU,GAAGL,IAAI,CAACM,MAAL,CAAYb,4BAA4B,CAACQ,KAAD,CAAxC,EAAiD,EAAjD,CAAjB;AACA,SAAOI,UAAU,CAAC,CAAD,CAAV,KAAkB,GAAlB,GAAwBA,UAAU,CAACE,KAAX,CAAiB,CAAjB,CAAxB,GAA8CF,UAArD;AACD,CAfM;AAgBP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,IAAIG,KAAK,GAAG,SAASA,KAAT,CAAeR,IAAf,EAAqB;AACtC,MAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC5B,WAAOJ,eAAe,CAACI,IAAD,CAAtB;AACD;;AAED,MAAIH,OAAO,CAACG,IAAD,CAAX,EAAmB;AACjB,WAAOL,GAAG,CAACK,IAAD,EAAON,qBAAP,CAAV;AACD;;AAED,MAAIe,kBAAkB,GAAGf,qBAAqB,CAACM,IAAD,CAA9C;AACA,SAAO,CAAC,OAAOS,kBAAP,KAA8B,QAA9B,GAAyCA,kBAAzC,GAA8D,KAAKA,kBAApE,CAAP;AACD,CAXM","sourcesContent":["// constants\nimport { VALID_QUOTES } from './constants'; // utils\n\nimport { createGetNormalizedCreateKey, getNormalizedParseKey, map, parseStringPath } from './utils';\nvar isArray = Array.isArray;\n/**\n * @function create\n *\n * @description\n * create a new path string based on the path and quote passed\n *\n * @param {Array<number|string>} path the path to convert to a string\n * @param {string} [quote=\"] the quote string to use when quoting keys\n * @returns {string} the path string\n */\n\nexport var create = function create(path, quote) {\n  if (quote === void 0) {\n    quote = '\"';\n  }\n\n  if (!isArray(path)) {\n    throw new ReferenceError('path passed must be an array');\n  }\n\n  if (!VALID_QUOTES.test(quote)) {\n    throw new SyntaxError(\"quote \" + quote + \" passed is invalid, must be \\\", `, or '.\");\n  }\n\n  var pathString = path.reduce(createGetNormalizedCreateKey(quote), '');\n  return pathString[0] === '.' ? pathString.slice(1) : pathString;\n};\n/**\n * @function parse\n *\n * @description\n * the path parsed into a valid array of keys / indices\n *\n * @param {Array<number|string>|number|string} path the path to parse\n * @returns {Array<number|string>} the parsed path\n */\n\nexport var parse = function parse(path) {\n  if (typeof path === 'string') {\n    return parseStringPath(path);\n  }\n\n  if (isArray(path)) {\n    return map(path, getNormalizedParseKey);\n  }\n\n  var normalizedParseKey = getNormalizedParseKey(path);\n  return [typeof normalizedParseKey === 'number' ? normalizedParseKey : \"\" + normalizedParseKey];\n};"]},"metadata":{},"sourceType":"module"}